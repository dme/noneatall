#!/usr/bin/env python

from wsgiref.simple_server import make_server
import os, re
import simplejson as json
import cgi

style_normal = 'style="font-family:serif;"'
style_fixed = 'style="font-family:monospace;"'

def threadlist(environ, start_response, d):
    res = []
    res.append('<table %s>\n' % style_normal)
    for l in d.splitlines():
        m = re.match('thread:([0-9A-Fa-f]*) (.*) (\[[0-9/]*\]) ([^;]*); (.*) \(([^()]*)\)$', l)
        if m:
            tid = m.group(1)
            date = m.group(2)
            count = m.group(3)
            authors = m.group(4)
            subject = m.group(5)
            tags = m.group(6)

            res.append('<tr><td>%s</td><td>%s</td><td>%s</td><td><a href="/show/thread:%s">%s</a></td><td>(%s)</td></tr>\n' % (date, count, authors[:59], tid, subject[:79], ' '.join(map(lambda s: '<a href="/tag:%s">%s</a>' % (s, s), tags.split()))))
        else:
            res.append('failed to parse: %s' % l)

    start_response("200 OK", [('content-type', 'text/html')])
    res.append('</table>\n')
    return res;

def messagelist(environ, start_response, d):
    res = []

    def wash(text):

        def wash_wrap(text):
            import textwrap

            r = ""
            for line in text.split('\n'):
                if len(line) > 80:
                    m = re.match('([> ]+)', line)
                    if m:
                        prefix = m.group(1)
                    else:
                        prefix = ''
                    r += textwrap.fill(line, subsequent_indent = prefix)
                else:
                    r += line
                r += '\n'
            return r

        def wash_compress_blank(text):
            regexp = re.compile('[\n]+', re.MULTILINE)
            return regexp.sub('\n', text)
            
        return wash_wrap(text)

    def output_body(body):
        for part in body:
            if part['content-type'].lower() == 'text/plain':
                res.append('<pre %s>\n' % style_fixed)
                res.append(cgi.escape(wash(part['content'])))
                res.append('</pre>\n')
            else:
                res.append('<em>Part of type %s.</em></br>' % part['content-type'])

    def output_head(head, depth):
        bg = 255-(depth*8)
        res.append('<div style="padding-left:10px; background: #%0x%0x%0x;">' % (bg, bg, bg))
        res.append('From: %s<br>\n' % (cgi.escape(head['headers']['From'])))
        res.append('Subject: %s<br>\n' % (cgi.escape(head['headers']['Subject'])))
        res.append('To: %s<br>\n' % (cgi.escape(head['headers']['To'])))
        res.append('Cc: %s<br>\n' % (cgi.escape(head['headers']['From'])))
        output_body(head['body'])

    def output_tail():
        res.append('</div>\n')

    def output_tree(tree, depth):
        (head, tail) = tree
        output_head(head, depth)
        output_thread(tail, depth + 1)
        output_tail()

    def output_thread(thread, depth):
        for tree in thread:
            output_tree(tree, depth)

    def output_forest(forest):
        for thread in forest:
            output_thread(thread, 0)

    res.append('<div %s>\n' % style_normal)

    forest = json.loads(d)
    output_forest(forest)

    res.append('</div>\n')

    start_response('200 OK', [('content-type', 'text/html')]);
    return res

def application(environ, start_response):
    command = None

    args = environ['PATH_INFO'].split('/')
    if args[1] == 'search':
        command = 'search ' + '/'.join(args[2:])
        processor = threadlist
    elif args[1] == 'show':
        command = 'show --format=json ' + '/'.join(args[2:])
        processor = messagelist

    if not command:
        command = 'search tag:inbox'
        processor = threadlist

    p = os.popen('notmuch ' + command)
    res = processor(environ, start_response, p.read())
    p.close()
    return res

def main():
    try:
        server = make_server('0.0.0.0', 10237, application);
        print 'Off and running...'
        server.serve_forever()
    except KeyboardInterrupt:
        print 'Bye!'

if __name__ == '__main__':
    main()
